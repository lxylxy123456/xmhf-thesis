\subsection{Performance Improvement}
\label{sec:impl_performance}

We use multiple techniques to improve the performance of \XMHF64. XMHF only supports compiling with GCC without optimization (O0). Without optimization, the code generated by GCC is inefficient. We fix a number of compile time and run time bugs to allow \XMHF64 to compile with GCC's highest optimization (O3) and run correctly. This improves the performance of \XMHF64.

\XMHF64 also leverages several VMX features provided by the CPU to reduce the number of intercepts, which improves its performance since intercepts are expensive \cite{agesen2012software}. One of these features is the MSR bitmap, which \XMHF64 uses to reduce the number of intercepts when the rich OS/Apps access MSRs. \XMHF64 configures the MSR bitmap to allow the rich OS/Apps to access exported MSRs directly. In contrast, XMHF does not use the MSR bitmap, resulting in an intercept being generated every time the rich OS/Apps access an MSR. Therefore, \XMHF64 generates fewer MSR intercepts than XMHF.

\XMHF64 also enables VMCS shadowing, a VMX feature in modern CPUs. This feature allows \XMHF64 to avoid unnecessary intercepts when the general-purpose hypervisor executes the read field from virtual-machine control structure (VMREAD) and write field to virtual-machine control structure (VMWRITE) instructions \cite{intel_vmcs_shadowing}.

