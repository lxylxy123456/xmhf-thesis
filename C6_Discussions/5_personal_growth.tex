\section{Development Process}

We are able to speed up the development of \XMHF64 by running it in general-purpose hypervisors like KVM \cite{kivity2007kvm, ben2010turtles}. KVM can simulate many hardware resources used by \XMHF64, including the hardware virtualization extension and the IOMMU. Virtual machines in KVM can be debugged using GDB, allowing us to view \XMHF64's registers and control its execution. In contrast, when developing on bare metal, we have to rely on print debugging. Debugging with KVM and GDB is especially helpful for us when developing the boot process and resolving race conditions. KVM also boots virtual machines faster than real hardware, which saves us time when testing bug fixes for \XMHF64.

We use continuous integration (CI) to automatically catch regression problems. We set up CI pipelines to run \XMHF64 and TrustVisor in KVM and test their basic functionalities. We use Jenkins \cite{jenkins_ci} as the platform to run CI pipelines on our local machine and CircleCI \cite{circle_ci} to run CI pipelines on the cloud. CircleCI supports nested virtualization, allowing us to run KVM on CircleCI. However, due to the overhead of nested virtualization in CircleCI, we need to compile \XMHF64 with the highest optimization.

Open source software helps us when developing \XMHF64. When \XMHF64 runs open source rich OS/Apps and general-purpose hypervisors like Linux and KVM, the entire software stack is transparent to us. For example, if Linux crashes as a rich OS in \XMHF64, we can debug Linux to see how \XMHF64 triggers the incorrect behavior in Linux. In return, we help the open source community by filing detailed bug reports. For example, for a few KVM bugs we encounter, we debug KVM and include the root causes of the bugs in the bug reports.

